<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B√© H·ªçc C·ªông Tr·ª´ (Ph·∫°m Vi 500)</title>
    <!-- T·∫£i Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#047857', /* M√†u xanh l√° c√¢y ƒë·∫≠m cho ti√™u ƒë·ªÅ */
                        'green-btn': '#10b981', 
                        'yellow-btn': '#f59e0b',
                        'red-btn': '#ef4444',
                        'purple-btn': '#8b5cf6', /* M√†u t√≠m m·ªõi cho n√∫t */
                        'card-bg-expr': '#e0f2f1', /* M√†u xanh nh·∫°t cho bi·ªÉu th·ª©c */
                        'card-bg-result': '#ede9fe', /* M√†u t√≠m nh·∫°t cho k·∫øt qu·∫£ */
                    },
                    borderRadius: {
                        '3xl': '1.5rem',
                    }
                }
            }
        }
    </script>
    <style>
        /* CSS t√πy ch·ªânh cho tr√≤ ch∆°i tr√¥ng th√¢n thi·ªán h∆°n */
        body { font-family: 'Inter', sans-serif; }
        .game-card {
            background: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .expression-box {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .score-item {
            font-size: 2rem; 
            font-weight: 700;
        }
        .score-label {
            font-size: 0.875rem;
            font-weight: 500;
        }
        .answer-btn {
            transition: transform 0.1s, opacity 0.1s, box-shadow 0.2s;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">

    <div id="app" class="w-full max-w-lg p-8 rounded-3xl mt-8 game-card">
        <h1 class="text-3xl font-extrabold text-center text-primary mb-1">
            L√†m To√°n C√πng B√©
        </h1>
        <p class="text-center text-gray-500 mb-6 text-sm">
            T√≠nh to√°n c·ªông tr·ª´ trong ph·∫°m vi 500 v√† ch·ªçn ƒë√°p √°n ƒë√∫ng!
        </p>

        <!-- Tr·∫°ng th√°i ƒêi·ªÉm s·ªë m·ªõi: Hi·ªÉn th·ªã T·ªïng s·ªë c√¢u ƒê√∫ng v√† T·ªïng s·ªë c√¢u Sai -->
        <div class="flex justify-center items-end space-x-6 mb-8">
            <!-- T·ªïng s·ªë c√¢u ƒê√∫ng -->
            <div class="flex flex-col items-center text-green-600">
                <span id="correct-count" class="score-item">0</span>
                <span class="score-label">ƒê√∫ng</span>
            </div>
            <!-- T·ªïng C√¢u ƒê√£ L√†m -->
            <div class="flex flex-col items-center text-gray-500">
                <span id="total-count" class="score-item text-4xl font-black">0</span>
                <span class="score-label">T·ªïng c√¢u</span>
            </div>
            <!-- T·ªïng s·ªë c√¢u Sai -->
            <div class="flex flex-col items-center text-red-600">
                <span id="incorrect-count" class="score-item">0</span>
                <span class="score-label">Sai</span>
            </div>
        </div>

        <!-- Th√¥ng b√°o (M·∫∑t c∆∞·ªùi) -->
        <div class="text-center mb-10">
            <div id="feedback-emoji" class="text-5xl">ü§î</div>
        </div>

        <!-- Khu v·ª±c b√†i to√°n t√≠nh to√°n -->
        <div id="problem-area" class="flex justify-center items-center gap-4 mb-12">
            <!-- Bi·ªÉu th·ª©c (V√≠ d·ª•: 123 + 45) -->
            <div id="expression" 
                 class="expression-box w-48 sm:w-64 h-20 flex items-center justify-center 
                        bg-card-bg-expr text-primary rounded-xl text-2xl sm:text-3xl font-bold">
                ? + ?
            </div>

            <!-- D·∫•u b·∫±ng -->
            <div id="equals-sign" class="text-3xl font-black text-gray-500">=</div>

            <!-- K·∫øt qu·∫£ (Ch·ªó tr·ªëng ƒë·ªÉ hi·ªÉn th·ªã sau khi tr·∫£ l·ªùi) -->
            <div id="result-placeholder" 
                 class="expression-box w-20 h-20 flex items-center justify-center 
                        bg-card-bg-result text-purple-600 rounded-xl text-2xl sm:text-3xl font-bold">
                ?
            </div>
        </div>

        <!-- Khu v·ª±c 4 ƒë√°p √°n tr·∫Øc nghi·ªám -->
        <div id="answer-buttons" class="grid grid-cols-2 gap-4 max-w-xs mx-auto">
            <!-- 4 n√∫t ƒë√°p √°n (s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng JS) -->
            <button data-value="0" class="answer-btn p-4 bg-green-btn text-white text-2xl font-bold rounded-xl shadow-lg hover:opacity-90 transition transform hover:scale-105">?</button>
            <button data-value="0" class="answer-btn p-4 bg-yellow-btn text-white text-2xl font-bold rounded-xl shadow-lg hover:opacity-90 transition transform hover:scale-105">?</button>
            <button data-value="0" class="answer-btn p-4 bg-red-btn text-white text-2xl font-bold rounded-xl shadow-lg hover:opacity-90 transition transform hover:scale-105">?</button>
            <button data-value="0" class="answer-btn p-4 bg-purple-btn text-white text-2xl font-bold rounded-xl shadow-lg hover:opacity-90 transition transform hover:scale-105">?</button>
        </div>
        
        <!-- Hi·ªÉn th·ªã l·ªói nghi√™m tr·ªçng (ƒë·ªÉ debug) -->
        <p id="error-message" class="text-xs text-red-500 mt-4 hidden text-center">
            <!-- L·ªói kh·ªüi t·∫°o s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
        </p>
    </div>

    <!-- Script Module ƒë·ªÉ s·ª≠ d·ª•ng Firebase Auth v√† Logic Game -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        /* ƒê√£ x√≥a c√°c import li√™n quan ƒë·∫øn Firestore v√¨ kh√¥ng c·∫ßn l∆∞u ƒëi·ªÉm cao nh·∫•t/chu·ªói ƒë√∫ng */

        // C√†i ƒë·∫∑t chung v√† Bi·∫øn to√†n c·ª•c
        const MAX_LIMIT = 500; // Gi·ªõi h·∫°n cho ph√©p t√≠nh v√† k·∫øt qu·∫£ (trong ph·∫°m vi 500)
        const SAMPLE_RATE = 24000;
        const NEXT_QUESTION_DELAY = 1500; // 1.5 gi√¢y

        // D·ªØ li·ªáu √¢m thanh PCM Base64 
        // Correct Sound (Ting/Tinh Tinh)
        const CORRECT_SOUND_B64 = "T1NHD1NHDFNUFxd/Y31uYnlraWluYn1oZnpkZGlkZmZtZm5vbnV2e3x/d4mJjoyOlpWcmo6OlpWcnJycnJycnJycnJycnJycnJycnJyc"; 
        // Incorrect Sound (Sad/Fail Sound)
        const SAD_SOUND_B64 = "DwsLDw0OEhESExQVFRUWGBcZGRsdHR4eHyAhICEiIyMjJCQjJSYoJCcqLCwvMjQ3Oj0/Q0VE"; 

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let auth; // Gi·ªØ l·∫°i Auth ƒë·ªÉ Canvas ho·∫°t ƒë·ªông
        let userId = null;
        let currentProblem = {};
        
        // C·∫≠p nh·∫≠t bi·∫øn ƒë·ªÉ theo d√µi t·ªïng s·ªë c√¢u ƒê√∫ng/Sai
        let totalCorrectCount = 0; // T·ªïng s·ªë c√¢u tr·∫£ l·ªùi ƒë√∫ng
        let totalIncorrectCount = 0; // T·ªïng s·ªë c√¢u tr·∫£ l·ªùi sai
        let totalCount = 0; // T·ªïng s·ªë c√¢u ƒë√£ l√†m

        // Tham chi·∫øu DOM
        const errorMessageElement = document.getElementById('error-message');
        const expressionElement = document.getElementById('expression'); // Bi·ªÉu th·ª©c
        const resultPlaceholderElement = document.getElementById('result-placeholder'); // K·∫øt qu·∫£
        const feedbackEmojiElement = document.getElementById('feedback-emoji');
        const correctCountDisplay = document.getElementById('correct-count'); // Hi·ªÉn th·ªã T·ªïng ƒê√∫ng
        const incorrectCountDisplay = document.getElementById('incorrect-count'); // Hi·ªÉn th·ªã T·ªïng Sai
        const totalCountDisplay = document.getElementById('total-count');
        const answerButtons = document.querySelectorAll('.answer-btn');

        // --- Audio Utilities ---

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcm16.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            let offset = 0;
            // RIFF chunk
            view.setUint32(offset, 0x52494646, false); offset += 4; // 'RIFF'
            view.setUint32(offset, 36 + dataSize, true); offset += 4; // File length
            view.setUint32(offset, 0x57415645, false); offset += 4; // 'WAVE'
            // FMT chunk
            view.setUint32(offset, 0x666d7420, false); offset += 4; // 'fmt '
            view.setUint32(offset, 16, true); offset += 4; // Chunk length
            view.setUint16(offset, 1, true); offset += 2; // PCM format
            view.setUint16(offset, numChannels, true); offset += 2; // Channels
            view.setUint32(offset, sampleRate, true); offset += 4; // Sample rate
            view.setUint32(offset, byteRate, true); offset += 4; // Byte rate
            view.setUint16(offset, blockAlign, true); offset += 2; // Block align
            view.setUint16(offset, bitsPerSample, true); offset += 2; // Bits per sample
            // DATA chunk
            view.setUint32(offset, 0x64617461, false); offset += 4; // 'data'
            view.setUint32(offset, dataSize, true); offset += 4; // Data size
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function playAudio(base64AudioData, sampleRate = SAMPLE_RATE) {
            try {
                const pcmDataBuffer = base64ToArrayBuffer(base64AudioData);
                const pcm16 = new Int16Array(pcmDataBuffer);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                const audio = new Audio(audioUrl);
                audio.volume = 0.5;
                audio.play().catch(e => console.log("L·ªói ph√°t √¢m thanh (c√≥ th·ªÉ do tr√¨nh duy·ªát ch·∫∑n):", e));
            } catch (e) {
                console.error("Kh√¥ng th·ªÉ ph√°t √¢m thanh:", e);
            }
        }

        const to = (promise) => {
            return promise.then(data => [null, data]).catch(err => [err, undefined]);
        };

        // --- Logic Game ---
        
        // H√†m t·∫°o m·ªôt bi·ªÉu th·ª©c ƒë∆°n (ƒë√£ c√≥ t·ª´ phi√™n b·∫£n tr∆∞·ªõc, ƒë∆∞·ª£c t·ªëi ∆∞u)
        function generateMathExpression() {
            const operator = Math.random() < 0.5 ? '+' : '-';
            let num1, num2, value;

            if (operator === '+') {
                // ƒê·∫£m b·∫£o t·ªïng trong ph·∫°m vi 500
                value = Math.floor(Math.random() * (MAX_LIMIT - 10)) + 10; 
                num1 = Math.floor(Math.random() * (value - 1)) + 1; 
                num2 = value - num1;
            } else { // '-'
                // ƒê·∫£m b·∫£o s·ªë b·ªã tr·ª´ t·ª´ 10 tr·ªü l√™n ƒë·ªÉ ph√©p tr·ª´ c√≥ √Ω nghƒ©a
                num1 = Math.floor(Math.random() * (MAX_LIMIT - 10)) + 10; 
                num2 = Math.floor(Math.random() * num1) + 1; 
                value = num1 - num2; 
            }
            
            return { text: `${num1} ${operator} ${num2}`, value: value };
        }
        
        function generateDistractor(correctValue, attempts = 0, optionsSet) {
            let distractor;
            
            // Chi·∫øn l∆∞·ª£c t·∫°o nhi·ªÖu:
            if (attempts % 4 === 0) {
                // Tweak h√†ng ch·ª•c: +/- 10, 20
                distractor = correctValue + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 2) + 1) * 10;
            } else if (attempts % 4 === 1) {
                // Tweak h√†ng ƒë∆°n v·ªã: +/- 1, 2
                distractor = correctValue + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 2) + 1);
            } else if (attempts % 4 === 2) {
                // ƒê·∫£o ng∆∞·ª£c ch·ªØ s·ªë cu·ªëi (ch·ªâ √°p d·ª•ng n·∫øu k·∫øt qu·∫£ > 10)
                if (correctValue >= 10) {
                    const str = String(correctValue);
                    const lastDigit = str[str.length - 1];
                    const secondLastDigit = str[str.length - 2];
                    // T·∫°o s·ªë nhi·ªÖu b·∫±ng c√°ch ƒë·∫£o ng∆∞·ª£c 2 ch·ªØ s·ªë cu·ªëi (n·∫øu c√≥)
                    let base = str.slice(0, -2);
                    distractor = parseInt(base + lastDigit + secondLastDigit);
                }
            } else {
                // S·ªë ng·∫´u nhi√™n trong kho·∫£ng g·∫ßn ( +/- 50 )
                distractor = correctValue + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 40) + 10);
            }
            
            // ƒê·∫£m b·∫£o distractor l√† s·ªë h·ª£p l·ªá, trong gi·ªõi h·∫°n v√† kh√¥ng tr√πng l·∫∑p
            distractor = Math.max(0, Math.min(MAX_LIMIT, distractor));
            
            // Tr√°nh tr√πng v·ªõi ƒë√°p √°n ƒë√∫ng v√† c√°c ƒë√°p √°n nhi·ªÖu ƒë√£ c√≥
            if (optionsSet.has(distractor) || distractor === correctValue) {
                // N·∫øu tr√πng, th·ª≠ l·∫°i v·ªõi chi·∫øn l∆∞·ª£c kh√°c
                return generateDistractor(correctValue, attempts + 1, optionsSet);
            }
            
            return distractor;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateProblem() {
            let problem = generateMathExpression(); // { text: "123 + 45", value: 168 }
            const correctAnswer = problem.value;
            const options = new Set([correctAnswer]);

            // Generate 3 unique incorrect options (distractors)
            let attempts = 0;
            while (options.size < 4 && attempts < 20) {
                let distractor = generateDistractor(correctAnswer, attempts, options);
                options.add(distractor);
                attempts++;
            }
            // N·∫øu v·∫´n kh√¥ng ƒë·ªß 4 ƒë√°p √°n (r·∫•t hi·∫øm), th√™m c√°c s·ªë ng·∫´u nhi√™n xa
            while (options.size < 4) {
                 options.add(Math.floor(Math.random() * MAX_LIMIT));
            }


            const optionArray = Array.from(options);
            shuffleArray(optionArray);

            currentProblem = { 
                expression: problem.text, 
                correctAnswer: correctAnswer,
                options: optionArray
            };
            
            expressionElement.textContent = currentProblem.expression;
            resultPlaceholderElement.textContent = '?'; 
            feedbackEmojiElement.textContent = 'ü§î'; 
            resultPlaceholderElement.classList.remove('text-green-600', 'text-red-600');
            resultPlaceholderElement.classList.add('text-purple-600'); // Reset color

            // Map options to buttons
            answerButtons.forEach((btn, index) => {
                const optionValue = currentProblem.options[index];
                btn.textContent = optionValue;
                btn.setAttribute('data-value', optionValue);
            });
        }

        function checkAnswer(selectedValue) {
            answerButtons.forEach(btn => btn.disabled = true);
            
            const selectedValueNumber = parseInt(selectedValue);
            const isCorrect = selectedValueNumber === currentProblem.correctAnswer;
            
            totalCount++;
            let emoji;
            let finalResultColor;

            if (isCorrect) {
                totalCorrectCount++; // TƒÉng t·ªïng s·ªë c√¢u ƒë√∫ng
                emoji = 'ü•≥'; 
                finalResultColor = 'text-green-600';
                playAudio(CORRECT_SOUND_B64, SAMPLE_RATE); 
            } else {
                totalIncorrectCount++; // TƒÉng t·ªïng s·ªë c√¢u sai
                emoji = 'üòî'; 
                finalResultColor = 'text-red-600';
                playAudio(SAD_SOUND_B64, SAMPLE_RATE); 
            }
            
            // Highlight the correct answer among options for visual feedback
            answerButtons.forEach(btn => {
                const btnValue = parseInt(btn.getAttribute('data-value'));
                // N·∫øu l√† ƒë√°p √°n ƒë√∫ng, th√™m highlight m√†u xanh
                if (btnValue === currentProblem.correctAnswer) {
                    btn.classList.add('ring-4', 'ring-green-500', 'ring-offset-2', 'shadow-2xl');
                } 
                // N·∫øu l√† ƒë√°p √°n ng∆∞·ªùi d√πng ch·ªçn v√† b·ªã sai, th√™m highlight m√†u ƒë·ªè
                else if (btnValue === selectedValueNumber && !isCorrect) {
                    btn.classList.add('ring-4', 'ring-red-500', 'ring-offset-2', 'shadow-2xl');
                }
            });

            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm s·ªë (T·ªïng ƒê√∫ng / T·ªïng Sai)
            correctCountDisplay.textContent = totalCorrectCount; 
            incorrectCountDisplay.textContent = totalIncorrectCount; 
            totalCountDisplay.textContent = totalCount;
            feedbackEmojiElement.textContent = emoji;
            resultPlaceholderElement.textContent = currentProblem.correctAnswer; 
            resultPlaceholderElement.classList.remove('text-purple-600');
            resultPlaceholderElement.classList.add(finalResultColor);

            // Chuy·ªÉn sang c√¢u h·ªèi ti·∫øp theo
            setTimeout(() => {
                // Reset button highlights
                answerButtons.forEach(btn => {
                    btn.classList.remove('ring-4', 'ring-green-500', 'ring-red-500', 'ring-offset-2', 'shadow-2xl');
                });
                
                generateProblem();
                answerButtons.forEach(btn => btn.disabled = false);
            }, NEXT_QUESTION_DELAY); 
        }

        // --- Kh·ªüi t·∫°o v√† S·ª± ki·ªán ---

        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.warn('C·∫•u h√¨nh Firebase kh√¥ng kh·∫£ d·ª•ng. Ch·ªâ ch∆°i ngo·∫°i tuy·∫øn.');
                    return;
                }
                
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                
                if (initialAuthToken) {
                    const [error] = await to(signInWithCustomToken(auth, initialAuthToken));
                    if (error) await signInAnonymously(auth);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        // Kh√¥ng c·∫ßn g·ªçi loadHighScore/saveHighScore n·ªØa
                    } else {
                        userId = null;
                        console.log('ƒêƒÉng nh·∫≠p ·∫©n danh th·∫•t b·∫°i.');
                    }
                });

            } catch (error) {
                errorMessageElement.textContent = `L·ªói kh·ªüi t·∫°o: ${error.message}`;
                errorMessageElement.classList.remove('hidden');
                console.error("L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o Firebase:", error);
            }
        }

        function startGame() {
            generateProblem();
            // G·∫Øn s·ª± ki·ªán cho c√°c n√∫t tr·∫£ l·ªùi
            answerButtons.forEach(button => {
                button.disabled = false;
                button.addEventListener('click', (e) => {
                    const selectedAnswerValue = e.currentTarget.getAttribute('data-value');
                    checkAnswer(selectedAnswerValue);
                });
            });
        }
        
        window.onload = () => {
            startGame();
            initializeFirebase();
        }
    </script>
</body>
</html>
